#!/usr/bin/env ruby
# @Author: vargash1
# @Name:   Vargas, Hector
# @Email:  vargash1@wit.edu
# @Date:   2015-02-23 10:23:20
# @Last Modified by:   vargash1
# @Last Modified time: 2015-06-30 12:22:35
require 'colorize'
class BoolCalc
    def print_all_radix(num)
        print "Base 10:\t".yellow; print "#{num.to_s(10)}\n"
        print "Base 16:\t".yellow; print "#{num.to_s(16)}\n"
        print "Base 8: \t".yellow; print "#{num.to_s(8)}\n"
        print "Base 2:\n".yellow
        print_nice_binary(num)
    end
    def execute()
        print "\t---------------------------------------\n".green
        print_all_radix(@x)
        if (@y != nil)
            puts "\t---------------------------------------\n".green
            print_all_radix(@y)
        end
        case 
        when(@operation == 'RAD')
            return
        when (@operation == 'AND')
            final_result = @x & @y
        when (@operation == 'OR')
            final_result = @x | @y
        when (@operation == 'XOR')
            final_result = @x ^ @y 
        when (@operation == 'NOT')
            final_result = ~@x
        when (@operation == 'SHR')
            final_result = @x >> @y
        when (@operation == 'SHL')
            final_result = @x << @y
        when (@operation == 'ROL')
            int_to_binary_arr()
            rol()
            final_result = (@bit64_array_x.join).to_i(2)
        when(@operation == 'ROR')
            int_to_binary_arr()
            ror()
            final_result = (@bit64_array_x.join).to_i(2)
        when(@operation == 'MUL')
            final_result = @x * @y
        when(@operation == 'ADD')
            final_result = @x + @y
        when(@operation == 'DIV')
            final_result = @x / @y
        when(@operation == 'SUB')
            final_result = @x - @y
        when(@operation == 'MOD')
            final_result = @x % @y
        when(@operation == 'POW')
            final_result = @x ** @y
        end
        puts "\n\t-------------#{@operation} Result-----------------".green
        print_all_radix(final_result)   
    end
    def check_for_errors()
        if (@operation == nil)
            abort ("ERROR, Expected Operation".red)
        end
        #not operation is unary
        #rad can be either unary or binary
        #following logic avoids running a binary operation when user entered
        #only one number
        operation_restriction = (@operation != "NOT" && @operation != "RAD")
        if ((operation_restriction && (@y == nil || @y == 0)) || (@x == nil || @x == 0))
            abort("ERROR, Missing Numbers for Operation:\t#{@operation}".red)
        end
    end   
    def parse_args()
        ops = ['NOT','SHR','SHL','AND','OR','XOR','RAD','ROL','ROR','MUL','DIV','ADD','SUB','MOD','POW']
        if (ARGV.length == 0 || (ARGV[0].upcase) == "-H")
            print_help()
            exit
        end
        ARGV.each do |a|
            case 
            #if ARGV[a] is letters only,check if its a valid operation
            when (a == a[/[a-zA-Z]*/])
                ops.each do |ops_elem|
                    if (a.upcase == ops_elem)
                        @operation = ops_elem
                    end
                end
            #hex val was read
            when(a == a[/0[xX][0-9a-fA-F]+/])
                if (@x == nil) ? @x = a.to_i(16): @y = a.to_i(16)
                end
            #binary val was read
            when(a == a[/0[bB][0-1]+/])
                if (@x == nil) ? @x = a.to_i(2): @y = a.to_i(2)
                end
            #octal val was read
            when(a == a[/0[0-7]+/])
                if (@x == nil) ? @x = a.to_i(8): @y = a.to_i(8)
                end
            #decimal val was read
            when (is_number(a.to_i))
                if (@x == nil) ? @x = a.to_i: @y = a.to_i
                end
            end
        end
    end
    def is_number(num)
        is_num = ((num.to_f.to_s == num.to_s) || (num.to_i.to_s == num.to_s))
        return is_num
    end
    def print_help()
        puts """
        Usage(any of the following are acceptable):
        \tbitwiseCalc <num> <operation>
        \tbitwiseCalc <num> <num> <operation>
        \tbitwiseCalc <num> <operation> <num>\n
        
        Passing <num> in a radix other than base10:
        <base_2_num>  = 0b[0-1]
        <base_8_num>  = 0[0-7]
        <base_16_num> = 0x[0-9a-f]
        
            NOT x
                Displays ~x 
            x y RAD 
                Displays x and y in hex, octal, binary, and decimal radixes.
                1 number argument is sufficient.
            x AND y
                Displays x & y  
            x OR y
                Displays x | y 
            x XOR y
                Displays x XOR y
            x SHR y
                Displays x Shifted Right y times
            x SHL y
                Displays x Shifted Left y times
            x ROR y 
                Displays x Rotated Right y times 
            x ROL y
                Displays x Rotated Left y times 
            x MUL y
                Displays x * y 
            x DIV y
                Displays x divided by y
            x ADD y 
                Displays x + y
            x SUB y 
                Displays x - y
            x MOD y 
                Displays x modulus y
            x POW y
                Displays x to the power of y
        """
        exit
    end
    #outputs num in binary form
    #adds a space every 4 bits 
    def print_nice_binary(num)
        if num <= (2**31)
            puts "\t32 Bit Format".yellow
            print "\t"
            31.downto(0) do |n| 
                print num[n]
                if (n%4 == 0); print " " end
            end
        end
        if num <= (2**63)
            puts "\n\t64 Bit Format".yellow
            print "\t"
            63.downto(0) do |n|
                print num[n]
                if (n%4 == 0); print " " end
            end
        else
            puts "\n\t128 Bit Format".yellow
            print "\t"
            127.downto(0) do |n|
                if (n == 63); print"\n\t" end
                print num[n]
                if (n%4 == 0); print " " end
            end
        end
        puts
    end
    #converts an integer to a binary array
    def int_to_binary_arr()
        @bit64_array_x = []
        63.downto(0) do |n|
            @bit64_array_x << @x[n]
        end
    end
    def ror()
        arr_tail = @bit64_array_x.length-2
        for i in 1..@y
            #save least significant bit(end of array) 
            lsb = @bit64_array_x[-1]
            for j in 0..arr_tail
                if j == 0
                    tmp1 = @bit64_array_x[j+1]
                    @bit64_array_x[j+1] = @bit64_array_x[j]
                end
                #save next element, make next element previously saved elem
                tmp2 = @bit64_array_x[j+1]
                @bit64_array_x[j+1] = tmp1
                tmp1 = tmp2  
            end
            #assign least significant bit(end of array) to head of array
            @bit64_array_x[0] = lsb
        end
    end
    def rol()
        arr_tail = @bit64_array_x.length-2
        for i in 1..@y
            #save most significant bit(beginning of array)
            msb = @bit64_array_x[0]
            for j in 0..arr_tail
                #assign next element in array to current element in array
                @bit64_array_x[j] = @bit64_array_x[j+1]
            end
            #assign most significant bit to tail
            @bit64_array_x[-1] = msb
        end 
    end       
end
def main()
    runtime = BoolCalc.new()
    runtime.parse_args()
    runtime.check_for_errors()
    runtime.execute()
end
main()  
