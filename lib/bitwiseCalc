#!/usr/bin/env ruby
# @Author: vargash1
# @Name:   Vargas, Hector
# @Email:  vargash1@wit.edu
# @Date:   2015-02-23 10:23:20
# @Last modified by:   vargash1
# @Last modified time: Monday, May 9th 2016, 10:02:38 pm
require 'colorize'
class BoolCalc
    def initialize()
        @x = nil; @y = nil; @ans = nil; @operation = nil
        # Valid Operations
        @ops = ['NOT','SHR','SHL','AND','OR','XOR',
                'RAD','ROL','ROR','MUL','DIV','ADD',
                'SUB','MOD','POW','NOR','NAND','XNOR']
        # Operation hash with a more verbose description
        @ops2 = { 'NOT' => "Bitwise Not", 'SHR' => "Shift Right",
            'SHL' => "Shift Left", 'AND' => "Logical And",
            'OR' => "Logical Or", 'XOR' => "Exclusive Or",
            'RAD' => "Display Radixes", 'ROL' => "Circular Rotate Left",
            'ROR' => "Circular Rotate Right",'MUL' => "Multiply",
            'DIV' => " Division", 'ADD' => "Addition",
            'SUB' => "Subtraction", 'MOD' => "Modulus",
            'POW' => "Exponentiation",'NOR' => "Negated OR",
            'NAND' => "Negated AND", 'XNOR' => "Complement XOR"}
        # Option Hash
        @options = { nocolor:false, grouped: false, bit4: true,
                     bit64: true, ipnum: false, nargs: false }
    end
    # Outputs num in radixes mentioned in program description.
    def print_all_radix(num)
        num_base10 = num.to_s(10)

        num.to_s(10).reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse! if @options[:grouped]
        print "Base 2:\n".yellow
        print_nice_binary(num)
        print "Base 8: \t".yellow; print "#{num.to_s(8)}\n"
        print "Base 10:\t".yellow; print "#{num_base10}\n"
        print "Base 16:\t".yellow; print "#{num.to_s(16)}\n"
    end
    # Executes desired operation.
    def execute()
        case
        when(@operation == 'RAD')
            return
        when (@operation == 'AND')
            @ans = @x & @y
        when (@operation == 'NAND')
            @ans = ~(@x & @y)
        when (@operation == 'OR')
            @ans = @x | @y
        when (@operation == 'NOR')
            @ans = ~(@x | @y)
        when (@operation == 'XOR')
            @ans = @x ^ @y
        when (@operation == 'XNOR')
            @ans = ~(@x ^ @y)
        when (@operation == 'NOT')
            @ans = ~@x
        when (@operation == 'SHR')
            @ans = @x >> @y
        when (@operation == 'SHL')
            @ans = @x << @y
        when (@operation == 'ROL')
            binarr = int_to_binarr(@x)
            binarr = rol(binarr)
            @ans = binarr.join.to_i(2)
        when(@operation == 'ROR')
            binarr = int_to_binarr(@x)
            binarr = ror(binarr)
            @ans = (binarr.join).to_i(2)
        when(@operation == 'MUL')
            @ans = @x * @y
        when(@operation == 'ADD')
            @ans = @x + @y
        when(@operation == 'DIV')
            @ans = @x / @y
        when(@operation == 'SUB')
            @ans = @x - @y
        when(@operation == 'MOD')
            @ans = @x % @y
        when(@operation == 'POW')
            @ans = @x ** @y
        end
    end
    # Neatly displays results
    def print_results()
        String.disable_colorization = true if (@options[:nocolor])
        seperator = "\t---------------------------------------\n"
        print seperator.green
        print_all_radix(@x)

        # print 2 passed num only if
        if @y != nil && @operation != "NOT"
            puts seperator.green
            print_all_radix(@y)
        end

        # rad simply outputs num(s) in multiple radixes
        if @operation != "RAD"
            puts "\n\t-------------#{@operation} Result-----------------".green
            print_all_radix(@ans)
        end
    end

    # Detect any errors before operation execution
    def check_for_errors()
        # no operation read
        abort("ERROR, Expected Operation".red) if (@operation.nil?)

        # make sure binary operations have binary input
        restriction = (@operation != "NOT" && @operation != "RAD") && @y.nil?
        # also make sure we have read at least 1 number
        if restriction || @x.nil?
            abort("ERROR, Expected Number(s) for Operation:\t#{@operation}".red)
        end

        # div by zero
        if (@operation == "DIV" || @operation == "MOD") && @y == 0
            abort("ERROR, Divide by 0 for Operation:\t#{@operation}".red)
        end
    end

    # Use regular expressions to parse arguments passed.
    def parse_args()
        #exit if no args passed; parse flags only if needed
        usage() if ARGV.empty?
        parse_flags if (ARGV[0][0] == "-")

        ARGV.each do |a|
            case
            #check if valid operation choice
            when (a == a[/[a-zA-Z]*/])
                @ops.each do |ops_elem|
                    if (a.upcase == ops_elem)
                        @operation = ops_elem
                    end
                end
            #hex val was read
            when(a == a[/0[xX][0-9a-fA-F]+/])
                if (@x == nil) ? @x = a.to_i(16): @y = a.to_i(16)
                end
            #binary val was read
            when(a == a[/0[bB][0-1]+/])
                if (@x == nil) ? @x = a.to_i(2): @y = a.to_i(2)
                end
            #octal val was read
            when(a == a[/0[0-7]+/])
                if (@x == nil) ? @x = a.to_i(8): @y = a.to_i(8)
                end
            #decimal val was read
            when (is_number(a))
                if (@x == nil) ? @x = a.to_i: @y = a.to_i
                end
            end
        end
    end
    # Parses flags, only called if flags passed are detected.
    def parse_flags()
        flags = ARGV[0]
        flags.split("").each do |f|
            case
            when f == "n"
                @options[:nocolor] = true
            when f == "h"
                usage
            when f == "f"
                @options[:bit4] = false
            when f == "s"
                @options[:bit64] = false
            when f == "g"
                @options[:grouped] = true
            end
        end
    end
    # Simple way to check if our number is truly a number
    def is_number(num)
        is_num = ((num.to_f.to_s == num.to_s) || (num.to_i.to_s == num.to_s))
        is_num
    end
    def usage()
        puts """
        Description:
            A simple bitwise calculator that executes the operations noted below.
            It can accept Octal, Hexadecimal, Decimal, and Binary inputs.
            It will output in above mentioned radixes, binary output
            will have 32,64,128, and up to 256 bit format. The results are printed to
            STDOUT.
            Note this was intended to be a command line interface tool only.

        Usage:
            Pass arguments to the program as shown below.
            Note that binary output is spaced every 4 bits.
            Every 64 bits, a newline is added for readability.
            Colorized output is also enabled by default.
            Of course you can disable these if you wish.

            For additional help/screenshots:
            <https://github.com/vargash1/Bitwise-Calculator>

            Unary Operations:
                bitwiseCalc <flag> <num> <operation>

            Binary Operations:
                bitwiseCalc <flag> <num> <operation> <num>

            Passing a number in a radix other than base10:
                <base_2_num>  = 0b[0-1]
                <base_8_num>  = 0[0-7]
                <base_16_num> = 0x[0-9a-f]
        Flags:
            -f
                disables spacing every 4 bits in binary output
            -s
                disables newline every 64 bits in binary output
            -n
                disables colorized output
            -h
                outputs usage and exits
            -g
                outputs base 10 numbers in grouped form
        Operations:"""
        @ops2.each_pair do |k,v|
            puts "\t #{k}\n\t\t#{v}"
        end
        exit
    end
    # Outputs number in Binary form for easier reading
    # Will print 64 bits before moving to the next line
    def print_nice_binary(num)
        case
        when num <= 2 ** 31
            max = 31
        when num <= 2 ** 63
            max = 63
        when num <= 2 ** 127
            max = 127
        else
            max = 255
        end
        puts "\t#{max+1} Bit Format(MSB First)".yellow
        print "\t"
        # ugly but formats output nicely
        max.downto(0) do |n|
            case
            when ((n+1)%64 == 0) && @options[:bit64]
                print "\n\t"
            when ((n+1)%4 == 0) && @options[:bit4]
                print " "
            end
            print num[n]
        end
        puts
    end
    #Converts an integer to a binary array
    def int_to_binarr(arr)
        tmparr = []
        255.downto(0) do |n|
            tmparr << arr[n]
        end
        tmparr
    end
    # Rotate right implementation
    def ror(tmparr)
        arr_tail = tmparr.length-2
        for i in 1..@y
            #save least significant bit(end of array)
            lsb = tmparr[-1]
            for j in 0..arr_tail
                if j == 0
                    tmp1 = tmparr[j+1]
                    tmparr[j+1] = tmparr[j]
                end
                #save next element, make next element previously saved elem
                tmp2 = tmparr[j+1]
                tmparr[j+1] = tmp1
                tmp1 = tmp2
            end
            #assign least significant bit(end of array) to head of array
            tmparr[0] = lsb
        end
        print tmparr.length
        tmparr
    end
    # Rotate left implementation
    def rol(tmparr)
        arr_tail = tmparr.length-2
        for i in 1..@y
            #save most significant bit(beginning of array)
            msb = tmparr[0]
            for j in 0..arr_tail
                #assign next element in array to current element in array
                tmparr[j] = tmparr[j+1]
            end
            #assign most significant bit to tail
            tmparr[-1] = msb
        end
        tmparr
    end
end
def main()
    runtime = BoolCalc.new()
    runtime.parse_args()
    runtime.check_for_errors()
    runtime.execute()
    runtime.print_results()
end
main()
