#!/usr/bin/env ruby
# @Author: vargash1
# @Name:   Vargas, Hector
# @Email:  vargash1@wit.edu
# @Date:   2015-02-23 10:23:20
# @Last Modified by:   vargash1
# @Last Modified time: 2015-09-17 20:41:15
require 'colorize'
class BoolCalc
    def initialize()
        @x = nil; @y = nil; @ans = nil; @operation = nil
        # Valid Operations 
        @ops = ['NOT','SHR','SHL','AND','OR','XOR',
                'RAD','ROL','ROR','MUL','DIV','ADD',
                'SUB','MOD','POW','NOR','NAND','XNOR']
        # Flags
        @no_color = false
    end
    # Outputs num in radixes mentioned in program description.
    def print_all_radix(num)
        print "Base 10:\t".yellow; print "#{num.to_s(10)}\n"
        print "Base 16:\t".yellow; print "#{num.to_s(16)}\n"
        print "Base 8: \t".yellow; print "#{num.to_s(8)}\n"
        print "Base 2:\n".yellow
        print_nice_binary(num)
    end
    # Executes desired operation.
    def execute()
        case 
        when(@operation == 'RAD')
            return
        when (@operation == 'AND')
            @ans = @x & @y
        when (@operation == 'NAND')
            @ans = ~(@x & @y) 
        when (@operation == 'OR')
            @ans = @x | @y
        when (@operation == 'NOR')
            @ans = ~(@x | @y)
        when (@operation == 'XOR')
            @ans = @x ^ @y 
        when (@operation == 'XNOR')
            @ans = ~(@x ^ @y)
        when (@operation == 'NOT')
            @ans = ~@x
        when (@operation == 'SHR')
            @ans = @x >> @y
        when (@operation == 'SHL')
            @ans = @x << @y
        when (@operation == 'ROL')
            int_to_binary_arr()
            rol()
            @ans = (@bit64_array_x.join).to_i(2)
        when(@operation == 'ROR')
            int_to_binary_arr()
            ror()
            @ans = (@bit64_array_x.join).to_i(2)
        when(@operation == 'MUL')
            @ans = @x * @y
        when(@operation == 'ADD')
            @ans = @x + @y
        when(@operation == 'DIV')
            @ans = @x / @y
        when(@operation == 'SUB')
            @ans = @x - @y
        when(@operation == 'MOD')
            @ans = @x % @y
        when(@operation == 'POW')
            @ans = @x ** @y
        end
    end
    # Neatly displays results
    def print_results()
        print "\t---------------------------------------\n".green
        print_all_radix(@x)
        if (@y != nil && @operation != "NOT")
            puts "\t---------------------------------------\n".green
            print_all_radix(@y)
        end
        # rad simply outputs num(s) in multiple radixes
        if (@operation != "RAD")
            puts "\n\t-------------#{@operation} Result-----------------".green
            print_all_radix(@ans)
        end    
    end
    
    # Detect any errors before operation execution
    def check_for_errors()
        # no operation read
        abort("ERROR, Expected Operation".red) if (@operation.nil?)
        # at least one number read to continue
        abort("ERROR, Expected Number(s) for #{@operation}".red) if (@x.nil?)

        # div by zero
        if ((@operation == "DIV" || @operation == "MOD") && (@y == 0))
            abort("ERROR, Divide by 0 for Operation:\t#{@operation}".red)
        end 

        # make sure binary operations have binary input 
        restriction = (@operation != "NOT" && @operation != "RAD")
        if restriction && (@y.nil?)  
            abort("ERROR, Expected Number(s) for Operation:\t#{@operation}".red)
        end
    end 
    
    # Use regular expressions to parse arguments passed.
    def parse_args(arr = nil)
        #exit if no args passed; parse flags only if needed
        usage() if ARGV.empty? 
        parse_flags if (ARGV[0][0] == "-")
        
        # for using in a script
        arr = ARGV if arr.nil?
        
        arr.each do |a|
            case 
            #if ARGV[a] is letters only,check if its a valid operation
            when (a == a[/[a-zA-Z]*/])
                @ops.each do |ops_elem|
                    if (a.upcase == ops_elem)
                        @operation = ops_elem
                    end
                end
            #hex val was read
            when(a == a[/0[xX][0-9a-fA-F]+/])
                if (@x == nil) ? @x = a.to_i(16): @y = a.to_i(16)
                end
            #binary val was read
            when(a == a[/0[bB][0-1]+/])
                if (@x == nil) ? @x = a.to_i(2): @y = a.to_i(2)
                end
            #octal val was read
            when(a == a[/0[0-7]+/])
                if (@x == nil) ? @x = a.to_i(8): @y = a.to_i(8)
                end
            #decimal val was read
            when (is_number(a))
                if (@x == nil) ? @x = a.to_i: @y = a.to_i
                end
            end
        end
    end
    # Parses flags, only called if flags passed are detected.
    def parse_flags()
        flags = ARGV[0]
        flags.split("").each do |f|
            usage() if f.upcase == "H" 
            @no_color = true if f.upcase == "N"
        end
        String.disable_colorization = true if (@no_color)
    end
    # Simple way to check if our number is truly a number
    def is_number(num)
        is_num = ((num.to_f.to_s == num.to_s) || (num.to_i.to_s == num.to_s))
        return is_num
    end
    def usage()
        puts """
        Description:
            A simple bitwise calculator that executes the operations noted below.
            It can accept Octal, Hexadecimal, Decimal, and Binary inputs.
            It will output in above mentioned radixes, binary output 
            will have 32,64, and up to 128 bit format. The results are printed to
            STDOUT.  
        Usage:
            Any flags passed MUST come first.
            Numbers, and operation order DOES NOT MATTER.
            Binary operations WILL be parsed left to right.

            Unary Operations:
                bitwiseCalc <flag> <num> <operation>
            
            Binary Operations:
                bitwiseCalc <flag> <num> <operation> <num>
            
            Passing a number in a radix other than base10:
                <base_2_num>  = 0b[0-1]
                <base_8_num>  = 0[0-7]
                <base_16_num> = 0x[0-9a-f]
        Flags: 
            -n
                disables colorized output(enabled by default)
            -h
                outputs usage and exits
        Operations:
            NOT 
                Bitwise NOT, or complement of input.   
            RAD    
                Diplays Input(s) in metioned radixes.   
            AND              
                Logical AND. 
            NAND 
                Negative AND.   
            OR 
                Logical inclusive OR.
            NOR
                Negative OR.
            XOR 
                Logical exclusive OR. 
            XNOR
                Logical complement of XOR. 
            SHR 
                Right logical shift. 
            SHL 
                Left logical shift.
            ROR  
                Right circular rotate.       
            ROL 
                Left circular rotate.   
            MUL 
                Multiplication.
            DIV 
                Division.
            ADD  
                Addition.
            SUB  
                Subtraction.
            MOD  
                Modulus.
            POW
                Exponentiation.
            """
        exit
    end
    # Outputs number in Binary form for easier reading
    # Plus it lets user see what is going on.
    def print_nice_binary(num)
        if num <= (2**31)
            puts "\t32 Bit Format(MSB First)".yellow
            print "\t"
            31.downto(0) do |n| 
                print num[n]
                if (n%4 == 0); print " " end
            end
            puts
        end
        if num <= (2**63)
            puts "\n\t64 Bit Format(MSB First)".yellow
            print "\t"
            63.downto(0) do |n|
                print num[n]
                print " " if (n%4 == 0) 
            end
        else
            puts "\n\t128 Bit Format(MSB First)".yellow
            print "\t"
            127.downto(0) do |n|
                print"\n\t" if (n == 63)
                print num[n]
                print " " if (n%4 == 0)
            end
        end
        puts
    end
    #Converts an integer to a binary array
    def int_to_binary_arr()
        @bit64_array_x = []
        63.downto(0) do |n|
            @bit64_array_x << @x[n]
        end
    end
    # Rotate right implementation 
    def ror()
        arr_tail = @bit64_array_x.length-2
        for i in 1..@y
            #save least significant bit(end of array) 
            lsb = @bit64_array_x[-1]
            for j in 0..arr_tail
                if j == 0
                    tmp1 = @bit64_array_x[j+1]
                    @bit64_array_x[j+1] = @bit64_array_x[j]
                end
                #save next element, make next element previously saved elem
                tmp2 = @bit64_array_x[j+1]
                @bit64_array_x[j+1] = tmp1
                tmp1 = tmp2  
            end
            #assign least significant bit(end of array) to head of array
            @bit64_array_x[0] = lsb
        end
    end
    # Rotate left implementation 
    def rol()
        arr_tail = @bit64_array_x.length-2
        for i in 1..@y
            #save most significant bit(beginning of array)
            msb = @bit64_array_x[0]
            for j in 0..arr_tail
                #assign next element in array to current element in array
                @bit64_array_x[j] = @bit64_array_x[j+1]
            end
            #assign most significant bit to tail
            @bit64_array_x[-1] = msb
        end 
    end       
end
def main()
    runtime = BoolCalc.new()
    runtime.parse_args()
    runtime.check_for_errors()
    runtime.execute()
    runtime.print_results()
end
main()  
