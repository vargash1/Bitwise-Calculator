#!/usr/bin/env ruby
# @Author: vargash1
# @Name:   Vargas, Hector
# @Email:  vargash1@wit.edu
# @Date:   2015-02-23 10:23:20
# @Last Modified by:   vargash1
# @Last Modified time: 2015-09-13 13:35:27
require 'colorize'
class BoolCalc
    def initialize()
        @x = nil ; @y = nil
        @ans = nil; @operation = nil
        # flags
        @no_color = false
        @ops = ['NOT','SHR','SHL','AND','OR','XOR','RAD','ROL','ROR','MUL','DIV','ADD','SUB','MOD','POW']
         
    end
    def print_all_radix(num)
        print "Base 10:\t".yellow; print "#{num.to_s(10)}\n"
        print "Base 16:\t".yellow; print "#{num.to_s(16)}\n"
        print "Base 8: \t".yellow; print "#{num.to_s(8)}\n"
        print "Base 2:\n".yellow
        print_nice_binary(num)
    end
    def execute()
        case 
        when(@operation == 'RAD')
            return
        when (@operation == 'AND')
            @ans = @x & @y
        when (@operation == 'OR')
            @ans = @x | @y
        when (@operation == 'XOR')
            @ans = @x ^ @y 
        when (@operation == 'NOT')
            @ans = ~@x
        when (@operation == 'SHR')
            @ans = @x >> @y
        when (@operation == 'SHL')
            @ans = @x << @y
        when (@operation == 'ROL')
            int_to_binary_arr()
            rol()
            @ans = (@bit64_array_x.join).to_i(2)
        when(@operation == 'ROR')
            int_to_binary_arr()
            ror()
            @ans = (@bit64_array_x.join).to_i(2)
        when(@operation == 'MUL')
            @ans = @x * @y
        when(@operation == 'ADD')
            @ans = @x + @y
        when(@operation == 'DIV')
            @ans = @x / @y
        when(@operation == 'SUB')
            @ans = @x - @y
        when(@operation == 'MOD')
            @ans = @x % @y
        when(@operation == 'POW')
            @ans = @x ** @y
        end
    end
    def print_results()
        print "\t---------------------------------------\n".green
        print_all_radix(@x)
        if (@y != nil)
            puts "\t---------------------------------------\n".green
            print_all_radix(@y)
        end
        # rad simply outputs num(s) in multiple radixes
        if (@operation != "RAD")
            puts "\n\t-------------#{@operation} Result-----------------".green
            print_all_radix(@ans)
        end    
    end
    def check_for_errors()
        # no operation specified
        abort ("ERROR, Expected Operation".red) if (@operation.nil?)
        
        # div by zero
        if ((@operation == "DIV" || @operation == "MOD") && (@y == 0))
            abort("ERROR, Divide by 0 for Operation:\t#{@operation}".red)
        end 

        # all other operations require binary input 
        restriction = (@operation != "NOT" && @operation != "RAD")
        if restriction && ((@y == nil ) && (@x == nil)) 
            abort("ERROR, Missing Numbers for Operation:\t#{@operation}".red)
        end
    end   
    def parse_args(arr = nil)
        #exit if no args passed; parse flags only if needed
        usage() if ARGV.empty? 
        parse_flags if (!is_number(ARGV[0]))
        
        arr = ARGV if arr.nil?
        arr.each do |a|
            case 
            #if ARGV[a] is letters only,check if its a valid operation
            when (a == a[/[a-zA-Z]*/])
                @ops.each do |ops_elem|
                    if (a.upcase == ops_elem)
                        @operation = ops_elem
                    end
                end
            #hex val was read
            when(a == a[/0[xX][0-9a-fA-F]+/])
                if (@x == nil) ? @x = a.to_i(16): @y = a.to_i(16)
                end
            #binary val was read
            when(a == a[/0[bB][0-1]+/])
                if (@x == nil) ? @x = a.to_i(2): @y = a.to_i(2)
                end
            #octal val was read
            when(a == a[/0[0-7]+/])
                if (@x == nil) ? @x = a.to_i(8): @y = a.to_i(8)
                end
            #decimal val was read
            when (is_number(a.to_i))
                if (@x == nil) ? @x = a.to_i: @y = a.to_i
                end
            end
        end
    end
    def parse_flags()
        flags = ARGV[0]
        flags.split("").each do |f|
            usage() if f == "H" 
            @no_color = true if f.upcase == "N"
        end
        String.disable_colorization = true if (@no_color)
    end
    def is_number(num)
        is_num = ((num.to_f.to_s == num.to_s) || (num.to_i.to_s == num.to_s))
        return is_num
    end
    def usage()
        puts """
        Usage
            bitwiseCalc [num] [operation]
            bitwiseCalc [num] [num] [operation]
            bitwiseCalc [num] [operation] [num]
        Flags 
            -n
                disables colorized output(enabled by default)
        
        Passing <num> in a radix other than base10:
            <base_2_num>  = 0b[0-1]
            <base_8_num>  = 0[0-7]
            <base_16_num> = 0x[0-9a-f]
        Operations
            NOT x
                Displays ~x 
            x y RAD 
                Displays x and y in hex, octal, binary, and decimal radixes.
                1 number argument is sufficient.
            x AND y
                Displays x & y  
            x OR y
                Displays x | y 
            x XOR y
                Displays x XOR y
            x SHR y
                Displays x Shifted Right y times
            x SHL y
                Displays x Shifted Left y times
            x ROR y 
                Displays x Rotated Right y times 
            x ROL y
                Displays x Rotated Left y times 
            x MUL y
                Displays x * y 
            x DIV y
                Displays x divided by y
            x ADD y 
                Displays x + y
            x SUB y 
                Displays x - y
            x MOD y 
                Displays x modulus y
            x POW y
                Displays x to the power of y
        """
        exit
    end
    #outputs num in binary form
    #adds a space every 4 bits 
    def print_nice_binary(num)
        if num <= (2**31)
            puts "\t32 Bit Format".yellow
            print "\t"
            31.downto(0) do |n| 
                print num[n]
                if (n%4 == 0); print " " end
            end
        end
        if num <= (2**63)
            puts "\n\t64 Bit Format".yellow
            print "\t"
            63.downto(0) do |n|
                print num[n]
                if (n%4 == 0); print " " end
            end
        else
            puts "\n\t128 Bit Format".yellow
            print "\t"
            127.downto(0) do |n|
                if (n == 63); print"\n\t" end
                print num[n]
                if (n%4 == 0); print " " end
            end
        end
        puts
    end
    #converts an integer to a binary array
    def int_to_binary_arr()
        @bit64_array_x = []
        63.downto(0) do |n|
            @bit64_array_x << @x[n]
        end
    end
    def ror()
        arr_tail = @bit64_array_x.length-2
        for i in 1..@y
            #save least significant bit(end of array) 
            lsb = @bit64_array_x[-1]
            for j in 0..arr_tail
                if j == 0
                    tmp1 = @bit64_array_x[j+1]
                    @bit64_array_x[j+1] = @bit64_array_x[j]
                end
                #save next element, make next element previously saved elem
                tmp2 = @bit64_array_x[j+1]
                @bit64_array_x[j+1] = tmp1
                tmp1 = tmp2  
            end
            #assign least significant bit(end of array) to head of array
            @bit64_array_x[0] = lsb
        end
    end
    def rol()
        arr_tail = @bit64_array_x.length-2
        for i in 1..@y
            #save most significant bit(beginning of array)
            msb = @bit64_array_x[0]
            for j in 0..arr_tail
                #assign next element in array to current element in array
                @bit64_array_x[j] = @bit64_array_x[j+1]
            end
            #assign most significant bit to tail
            @bit64_array_x[-1] = msb
        end 
    end       
end
def main()
    runtime = BoolCalc.new()
    runtime.parse_args()
    runtime.check_for_errors()
    runtime.execute()
    runtime.print_results()
end
main()  
